{"name": "tool_registration_execution", "description": "Register tools in registry and execute them with parameters", "given": ["A Registry instance", "One or more Tool implementations"], "when": ["Tools are registered via registry.register()", "Tool is retrieved via registry.get()", "Tool is executed with JSON parameters"], "then": ["Tools appear in registry.list()", "Tool executes and returns ToolResult", "Error cases return ToolResult with is_error=true"], "validates": ["Tool trait implementation", "Registry registration", "Tool execution lifecycle"]}
{"name": "agentic_loop_anthropic", "description": "Full agentic loop with tool calls using Anthropic Claude", "given": ["AnthropicClient with valid API key", "Registry with registered tools", "User message requiring tool use"], "when": ["Request sent with tools", "Response contains tool_use blocks", "Tools executed and results returned", "Follow-up request with tool results"], "then": ["Claude calls appropriate tool", "Tool results are incorporated", "Final response contains correct answer"], "validates": ["Anthropic API integration", "Tool calling protocol", "Conversation history management"]}
{"name": "mcp_server_connection", "description": "Connect to MCP server, initialize, list tools, call tools", "given": ["MCP server available (e.g., filesystem)", "McpServerConfig with stdio transport"], "when": ["McpClient::connect() called", "client.initialize() called", "client.list_tools() called", "client.call_tool() called"], "then": ["Connection established", "Tools listed with schemas", "Tool calls return McpToolResult", "Registry integration via merge_mcp works"], "validates": ["MCP protocol implementation", "JSON-RPC 2.0 communication", "McpProxyTool integration"]}
{"name": "streaming_responses", "description": "Stream responses token-by-token from LLM", "given": ["LlmClient implementation", "Request for text generation"], "when": ["create_message_stream() called", "Stream events consumed"], "then": ["MessageStart event received", "ContentBlockDelta events stream text", "MessageStop event signals completion"], "validates": ["SSE parsing", "Stream event types", "Async stream implementation"]}
{"name": "multi_provider", "description": "Same tool works with multiple LLM providers", "given": ["AnthropicClient and OpenAIClient", "Same Registry with tools", "Identical prompts"], "when": ["Request sent to each provider", "Agentic loop executed for each"], "then": ["Both providers call tools correctly", "Both arrive at correct answer", "Tool result format works for both"], "validates": ["LlmClient trait abstraction", "Provider-agnostic tool definitions", "OpenAI function calling compatibility"]}
{"name": "streaming_with_tools", "description": "Stream responses that include tool calls", "given": ["LlmClient with streaming", "Request with tools enabled"], "when": ["create_message_stream() called", "Tool call appears in stream"], "then": ["ContentBlockStart with ToolUse received", "Tool input accumulated from deltas", "Complete tool call reconstructable"], "validates": ["Streaming tool calls", "StreamAccumulator pattern", "Partial JSON assembly"]}
{"name": "subagent_basic", "description": "Spawn a subagent to execute a delegated task", "given": ["AgentRegistry with AgentDefinition", "Registry with tools", "LlmClient instance"], "when": ["SubAgent::new() with definition and client", "subagent.run(task) called"], "then": ["Subagent executes think-act loop", "Tools called as needed", "SubAgentResult returned with content, tool_use_count, usage"], "validates": ["SubAgent runner implementation", "AgentDefinition configuration", "Think-act loop execution"]}
{"name": "subagent_filtered_tools", "description": "Subagent with restricted tool access via allowlist/denylist", "given": ["Registry with multiple tools", "AgentDefinition with allowed_tools and denied_tools", "SubAgent instance"], "when": ["FilteredRegistry created from definition", "Subagent runs with filtered tools"], "then": ["Only allowed tools visible to subagent", "Denied tools blocked", "Subagent completes task with available tools"], "validates": ["FilteredRegistry decorator pattern", "Allowlist/denylist precedence", "Tool access control per agent"]}
{"name": "subagent_cross_provider", "description": "Subagents using different LLM providers", "given": ["Multiple AgentDefinitions with different models", "AnthropicClient and OpenAIClient", "Same tool registry"], "when": ["SubAgent created with each provider", "Same task executed by each"], "then": ["Both subagents complete task", "Both get correct answers", "Stats comparable between providers"], "validates": ["Cross-provider subagent support", "Model-specific SubAgent configuration", "Provider-agnostic SubAgent abstraction"]}
{"name": "mcp_sse_transport", "description": "Connect to MCP server via SSE/HTTP transport", "given": ["MCP server with HTTP/SSE endpoint", "McpServerConfig with Sse transport"], "when": ["McpClient::connect() called with SSE config", "client.initialize() called", "client.list_tools() called", "client.call_tool() called"], "then": ["SSE connection established", "Endpoint message received", "Tools listed and callable", "Responses received via SSE stream"], "validates": ["SSE transport implementation", "HTTP POST for requests", "SSE event parsing"]}
{"name": "mcp_resources", "description": "List and read MCP resources", "given": ["MCP server with resources capability", "Connected McpClient"], "when": ["client.list_resources() called", "client.read_resource(uri) called"], "then": ["Resources listed with URIs and names", "Resource content returned as text or blob", "Pagination via cursor works"], "validates": ["Resources capability", "Resource content types", "Pagination handling"]}
{"name": "mcp_prompts", "description": "List and get MCP prompts with arguments", "given": ["MCP server with prompts capability", "Connected McpClient"], "when": ["client.list_prompts() called", "client.get_prompt(name, args) called"], "then": ["Prompts listed with arguments schema", "Prompt messages returned with content", "Arguments interpolated correctly"], "validates": ["Prompts capability", "Prompt argument handling", "PromptMessage structure"]}
{"name": "mcp_logging", "description": "Set MCP server log level", "given": ["MCP server with logging capability", "Connected McpClient"], "when": ["client.set_log_level(McpLogLevel::Debug) called"], "then": ["Server accepts log level change", "Subsequent log messages at new level"], "validates": ["Logging capability", "McpLogLevel enum serialization"]}
{"name": "mcp_full_lifecycle", "description": "Complete MCP session with all capabilities", "given": ["MCP server with tools, resources, prompts", "McpServerConfig (stdio or SSE)"], "when": ["Connect and initialize", "Check capabilities", "Use tools, resources, prompts", "Shutdown cleanly"], "then": ["All capabilities discovered via initialize", "Each capability works correctly", "Graceful shutdown"], "validates": ["Full MCP protocol compliance", "Capability negotiation", "Session lifecycle"]}
{"name": "web_fetch_basic", "description": "Fetch web content with WebFetchTool", "given": ["WebFetchTool instance", "Valid URL to fetch"], "when": ["Tool execute() called with URL", "HTML conversion option set"], "then": ["Content fetched successfully", "HTML converted to text if requested", "Long content truncated with notice"], "validates": ["HTTP GET requests", "HTML-to-text conversion", "Content truncation"]}
{"name": "web_fetch_error_handling", "description": "WebFetchTool handles errors gracefully", "given": ["WebFetchTool instance", "Invalid or unreachable URL"], "when": ["Tool execute() called with bad URL"], "then": ["ToolResult.is_error = true", "Helpful error message returned", "No crash or panic"], "validates": ["Error handling", "ToolResult error wrapping"]}
{"name": "web_search_basic", "description": "Search the web with WebSearchTool", "given": ["WebSearchTool instance", "Search query string"], "when": ["Tool execute() called with query", "max_results parameter set"], "then": ["Search results returned", "Results contain title, URL, snippet", "Result count respects max_results"], "validates": ["Web search via DuckDuckGo", "Result parsing", "Result limiting"]}
{"name": "web_tools_with_agent", "description": "LLM agent uses web tools for research", "given": ["LlmClient instance", "Registry with WebFetchTool and WebSearchTool", "User query requiring web access"], "when": ["Agent loop runs", "Agent chooses appropriate web tool", "Tool results returned to agent"], "then": ["Agent calls web_fetch or web_search", "Web content incorporated into response", "Agent provides accurate answer"], "validates": ["Agent-web tool integration", "Tool selection logic", "Multi-turn with web tools"]}
{"name": "builtin_tools_comprehensive", "description": "All built-in tools work correctly", "given": ["All built-in tools: ReadFileTool, WriteFileTool, ListFilesTool, SearchTool, BashTool, WebFetchTool, WebSearchTool"], "when": ["Each tool executed with valid params"], "then": ["All tools return expected results", "Error cases handled gracefully", "No crashes or panics"], "validates": ["Tool trait implementations", "Built-in tool correctness", "Error handling patterns"]}
