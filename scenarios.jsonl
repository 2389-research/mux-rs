{"name":"hook_security_block","description":"Security hook blocks dangerous tools","given":"A hook registry with SecurityHook blocking specific tools","when":"PreToolUse event fires for blocked tool","then":"HookAction::Block returned with policy message","validates":"Hook system can prevent dangerous operations"}
{"name":"hook_logging","description":"Logging hook captures all lifecycle events","given":"A hook registry with LoggingHook","when":"Multiple events fire (AgentStart, Iteration, PreToolUse, PostToolUse, AgentStop)","then":"All events captured in order","validates":"Hook system provides full observability"}
{"name":"hook_path_sanitization","description":"Path sanitization hook blocks traversal attempts","given":"A hook that checks for '..' in paths","when":"Tool called with path containing '..'","then":"HookAction::Block returned","validates":"Hooks can implement security policies"}
{"name":"hook_chain","description":"Multiple hooks chain correctly","given":"Registry with logging hook then security hook","when":"Event fires","then":"Logging sees event, security may block, order preserved","validates":"Hook composition works correctly"}
{"name":"edit_unique_replace","description":"Edit tool replaces unique string","given":"File with unique target string","when":"Edit called with old_string and new_string","then":"String replaced, file updated","validates":"Basic edit functionality"}
{"name":"edit_non_unique_fails","description":"Edit tool rejects non-unique match","given":"File with target string appearing multiple times","when":"Edit called without replace_all","then":"Error returned, file unchanged","validates":"Edit tool prevents ambiguous replacements"}
{"name":"edit_replace_all","description":"Edit tool bulk replacement","given":"File with target string appearing multiple times","when":"Edit called with replace_all: true","then":"All occurrences replaced","validates":"Intentional bulk replacement works"}
{"name":"edit_not_found","description":"Edit tool handles missing string","given":"File without target string","when":"Edit called","then":"Error returned explaining string not found","validates":"Clear error for missing target"}
{"name":"edit_multiline","description":"Edit tool handles multiline replacement","given":"File with multiline target","when":"Edit called with multiline old_string","then":"Entire block replaced, preserving surrounding content","validates":"Complex multi-line edits work"}
{"name":"transcript_save_load","description":"Transcript store saves and loads messages","given":"MemoryTranscriptStore","when":"Messages saved then loaded by agent_id","then":"All messages returned with content preserved","validates":"Basic transcript persistence"}
{"name":"transcript_nonexistent","description":"Transcript store handles missing agent","given":"MemoryTranscriptStore with no saved transcripts","when":"Load called for unknown agent_id","then":"None returned (not error)","validates":"Graceful handling of missing transcripts"}
{"name":"transcript_overwrite","description":"Transcript store overwrites existing","given":"MemoryTranscriptStore with existing transcript","when":"Save called again for same agent_id","then":"New transcript replaces old","validates":"Transcript update works"}
{"name":"transcript_tool_use","description":"Transcript preserves tool use messages","given":"Messages containing ToolUse and ToolResult blocks","when":"Saved and loaded","then":"Tool call details preserved exactly","validates":"Complex message types survive serialization"}
{"name":"transcript_shared_store","description":"Transcript store works across Arc clones","given":"MemoryTranscriptStore wrapped in Arc","when":"Multiple clones save/load","then":"All operations see same data","validates":"Thread-safe sharing works"}
